{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/#Web/","result":{"pageContext":{"currentCategory":"#Web","categories":["All","#AI","#자동화","#회고","#Etc","#React","#DesignPattern","#Web","#Git","#Next.js","#Javascript","#Book"],"edges":[{"node":{"id":"8c20534d-5d2f-5d66-97d3-4a0a18a3272b","excerpt":"HTTP 캐시 웹 브라우저가 서버로부터 받은 데이터를 일시적으로 저장하는 공간을 HTTP 캐시라고 한다. 캐시는 데이터,값을 복사해 임시로 저장하는 장소를 가르키고 AWS에 따르면 다양한 유형이 있다. (데이터의 복사본을 저장하는 장소는 캐시, 캐시에 복사본을 저장하고 있다가 요청시 제공하는 과정 전체는 캐싱이라 한다.) 다만 조건부 요청 헤더와의 상호작용에 대한 이 글에선 HTTP 캐시(웹 캐시)만 다룰 예정. HTTP 캐시는 웹 서비스 성능 최적화에 도움을 주는데, 이미지나 자바스크립트 파일 등을 매번 다운로드하지 않고 복사본을 캐시에 저장해 두었다가 이후의 요청에 (유효시간 검증 후)캐시의 리소스를 사용할 수 있기 때문이다. 우리가 어떤 페이지에 처음 진입할 때와 n번째 진입할 때의 로딩 속도가 차이나는 이유도 여기에 있다. HTTP 캐시는 주로 HTTP 헤더를 통해 제어되는데, 대표적인 헤더는 아래 정도가 있다.  : 캐시의 유효시간을 초 단위로 설정하거나 (max-age)…","fields":{"slug":"/web-http-cache/"},"frontmatter":{"categories":"#Web","title":"HTTP 캐시와 조건부 요청 헤더","date":"February 04, 2024"}},"next":{"fields":{"slug":"/journal-goodbye-2023/"}},"previous":{"fields":{"slug":"/react-compound-pattern/"}}},{"node":{"id":"3d8c0271-86fa-5503-a73f-05d7ab40af73","excerpt":"들어가며 회사 서비스는 Pretendard Variable 폰트를 사용하고 5개 국어 다국어 처리를 하고 있다. \n어느 날 일본어의 일부 문자에서만 폰트가 깨지는 이슈를 발견했는데, 비단 우리만 겪었던 문제는 아니였는지 \n기존 폰트와 별도로 일본어/한자 대응을 위한 Pretendard JP 폰트가 배포되어 있었다. 해당 이슈는 Pretendard JP 폰트와 unicode-range를 활용해 해결했는데,\n이와 같이 언어마다 혹은 문자에 따라 다른 폰트를 적용해야 할 경우 어떻게 처리하면 될지 정리해보는 글 @font-face unicode-range는 @font-face 로 정의한 폰트가 적용될 범위를 설정하는 속성으로, \n우선 @font-face부터 정리해보자. @font-face는 웹에 표시할 사용자 지정 글꼴을 정의하는 CSS의 규칙으로 사용자의 컴퓨터에 설치되지 않은 웹 폰트를 적용할 수 있게 해준다.\n적용할 땐 아래의 문법에 따라 사용하면 된다.  : 사용자가 지정하는 폰…","fields":{"slug":"/css-unicode-range/"},"frontmatter":{"categories":"#Web","title":"unicode-range로 언어(문자)에 따라 다른 폰트 적용하기","date":"February 12, 2023"}},"next":{"fields":{"slug":"/journal-career/"}},"previous":{"fields":{"slug":"/regexp/"}}},{"node":{"id":"5ac1a7ad-277a-511b-a8ef-6cf3d322d8f7","excerpt":"문제상황 회사 프로젝트에 드디어 storybook을 도입하게되어 싱글벙글했던 것도 잠시.. \nstorybook을 설치해 실행하고 기존에 만들어두었던 component의 story를 하나하나 작성하는데\nSVG 파일이 import된 component에선 undefined가 렌더된다는 아래의 에러가 떴다. 해당 에러는 storybook의 기본 웹팩 설정에서 svg 파일을 로 변환하고 있기 때문에 나는 것. React cra로 초기셋팅을 하며 storybook을 함께 적용할 때는 해당 에러가 나지않았고 \nmonorepo환경의 기존 프로젝트 (w/ React+Typescript)에 적용할때만 났다. 해결법 기존 웹팩 설정에서 svg와 관련된 설정을 삭제하고, SVG를 React Component로 변환해주는 tool인 SVGR을 통해\nSVG를 로드하도록 설정해 문제를 해결할 수 있다. 1. SVGR 설치 먼저, 기존 svg 처리 설정을 대체할 SVGR을 설치한다. 2. webpack 설정 …","fields":{"slug":"/css-storybook-svg-error/"},"frontmatter":{"categories":"#Web","title":"Storybook에서 SVG import Error 해결하기","date":"December 18, 2022"}},"next":{"fields":{"slug":"/journal-nhn-forward-2022/"}},"previous":{"fields":{"slug":"/journal-the-second-half-2022/"}}},{"node":{"id":"b4da1f1a-b7c5-5eb7-a9fd-067dbe50f0d3","excerpt":"들어가며 프로젝트를 진행할 때 JWT를 활용한 인증 방식으로 로그인을 구현한 적이 있다. \n백엔드 개발자분과 협업을 하며 key값을 맞춰보고, 인증이 완료되었다고 기뻐하던 추억은 선명하지만.. \nJWT가 무엇인가란 질문에 자신있게 대답할 수 없었다. \n추억속의 JWT를 꺼내 등장 배경부터 인증 프로세스, 장단점까지 알아보자. JWT의 등장배경 JWT가 무엇이고 어떤 형태로 사용되는지도 중요하지만, 먼저 그 배경을 알아야 어떤 장점과 특징을 가지고 있는지 제대로 이해할 수 있다. 그렇다면 JWT는 어떻게 등장하게 되었을까? 이는 HTTP의 특징과 연관된다. HTTP의 특징 HTTP는  (클라이언트의 요청이 처리되면 연결이 끊어짐),  (서버가 클라이언트의 이전 상태를 저장하지 않음)라는 특징을 가지고 있어\n인증이 필요한 페이지에 접근할 경우 서버는 클라이언트가 누구인지 매번 확인해야했다. 예를 들어 쇼핑몰에서 로그인을 하고 마음에 드는 제품을 장바구니에 담을 때마다 다시 로그인을 하…","fields":{"slug":"/web-jwt/"},"frontmatter":{"categories":"#Web","title":"JWT(JSON Web Token), 등장 배경부터 인증 방식까지","date":"June 19, 2022"}},"next":{"fields":{"slug":"/git-commitizen/"}},"previous":{"fields":{"slug":"/react-count-animation/"}}}]}},"staticQueryHashes":["1073350324","2009502679","2938748437"],"slicesMap":{}}